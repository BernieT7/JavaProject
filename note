import java.util.Scanner;

void main() {                                        // main其實也是一個方法，他是程式執行的進入點
    //System.out.print("哈囉");                       // 讓電腦印出文字
/* 資料型態
    // 字串: "哈囉"                                 一串字
    System.out.println("哈囉");
    // 字元: '嗨'                                   一個字
    System.out.println('嗨');
    // 整數: 7
    System.out.println(7);
    // 浮點數: 164.1
    System.out.println(164.1);
    // 布林值: true false
    System.out.println(true);
*/
/* 變數variable，創建變數要宣告他的資料型態
    // 字串(String)
    String name = "bernie";
    System.out.println(name);
    // 字元(char): '嗨'
    char hi = 'H';
    System.out.println(hi);
    // 整數(int): 7
    int num = 7;
    System.out.println(num);
    // 浮點數(double): 164.1
    double f = 164.1;
    System.out.println(f);
    // 布林值(boolean): true false
    boolean real = false;
    System.out.println(real);
*/
/* 整數的其他型態:不能超出範圍
     byte : -128 ~ 127
     short : -32768 ~ 32767
     *int : -2147483648 ~ 2147483647
     long : -9223372036854775808 ~ 9223372036854775807
     long num1 = nL       定義時後面要加一個L!!
*/
/* 浮點數的其他型態:
     float : 精準到小數點下7位左右
        float num1 = nf       定義時後面要加一個f!!
     *double : 精準到小數點下15位左右
*/
/* 取得使用者輸入
    Scanner scanner = new Scanner(System.in);               創建scanner
    System.out.println("請輸入你的名字");
    String name = scanner.nextLine();                       取得使用者輸入(字串)
    System.out.println("哈囉" + name);

    System.out.println("請輸入你的年紀");
    int age = scanner.nextInt();                            取得使用者輸入(整數)
    System.out.println(10 + age);

    System.out.println("請輸入你的身高");
    double height = scanner.nextDouble();                   取得使用者輸入(浮點數數)
    System.out.println("你的身高:" + height);                 字串跟整數相加，整數會變成字串
*/
/* 數學計算Math
     整數對整數運算只會取得整數(ex:10/3=3)
     %取餘數
     Math.max(x, y)      取(x, y)較大者
     Math.min(x, y)      取(x, y)較小者
     Math.pow(x, y)      x的y次方
     Math.round(x)       取x四捨五入
     Math.ceil(x)         取x無條件進位
     Math.floor(x)        取x無條件捨棄
     取小數點第n位: round(x*10)/10 小數點第一位
                  round(x*100)/100 小數點第二位
                      依此類推
*/
/*判斷語句if:
    如果...
        if(條件判斷) {

        };
    如果...否則
        if(條件判斷) {

        }else {

        };
    如果...或是如果...否則
        if(條件判斷) {

        }else if(條件判斷) {

        }else {

        };
*/
/*運算符號:
     &&且 ||或 !()否
     ==相等 !=不相等
     字串相等的比較要用.equals()
       String name = "123";
       System.out.println(name.equals("1"));
*/
/* switch語句
    switch(變數){
        case 變數值1:
            ...;
            break;
        case 變數值2:
            ...;
            break;
        .
        .
        .
        default:                            都不符合上面的case，不用break
            ...;
    }
*/
/* array陣列:可以一次儲存多個值
    String[] name = {name1, name2, ...}     字串陣列
    int[] scores = {1, 2, ...}              整數陣列
    double[] heights = {140.2, 150.4, ...}  浮點數陣列
    name[n]                                 取出陣列第n+1個值
    scores[n] = m                           把第n+1個值改成m
    datatype[] name = new datatype[n]       創建一個大小為n的陣列
    陣列.length                              可以取得陣列長度
*/
/* 2D陣列:陣列裡還有陣列
    datatype[][] name = {{name1, name2}, {name3,name4}, name5, ...}
    name[n][m]                              取出陣列中第n+1個陣列第m+1個值
    scores[n][m] = s                        把第n+1, m+1個值改成s
    datatype[][] name = new datatype[n][m]  創建一個大小為n*m的陣列
*/
/* while loop
    while(條件判斷) {                         先條件判斷再執行

    }
    do {                                    先執行再條件判斷

    }while(條件判斷);
*/
/* for loop
    for(初始化; 條件判斷; 改動){
        重複執行的程式碼
    }
    (ex: for(int i=0; i<scores.length; i++){})
    for(datatype i:array){                  依序取得陣列中的值，從第一個值到最後一個值
    }
*/
/* nested loop
    for(){
        for(){
        }
    }
*/
/* break, continue
    break:直接跳出整個迴圈
    continue:直接進入下一次迴圈
*/
/* random
    Random random = new Random();           創建隨機產生器
    int x = random.nextInt(n);              隨機產生一個0~n-1的整數
    double x = random.nextDouble();         隨機產生0~1的浮點數
    double x = random.nextDouble()*n;       隨機產生0~n的浮點數
    boolean x = random.nextBoolean()        隨機產生布林值
*/
/* class類別: 現實生活中有很多事是無法用現有的資料型態表示，所以需要另外寫一個類別，創建自己的資料型態
    people.Person person1 = new Person();   創建資料型態
    person1.name = ;                        賦值
    person1.age = 22;
    person1.height = 164.1;

    person1.isAdult();                      使用方法
    Person person1 = new Person("bernie", 22, 164.1);       創建時可以傳入參數至建構方法
*/
/* 變數有效範圍: 變數有效範圍只在最近的大括號裡面，此大括號內的大括號也可以用
*/
/* method overloading: 方法名字一樣可以，但是參數數量or參數形態要不一樣
    方法跟方法之間可以互相呼叫
*/
/* 字串方法
   String name = "...";
   name.length();                           取得字串長度
   name.toUpperCase();                      把字母都轉換成大寫
   name.toLowerCase();                      把字母都換成小寫
   name.charAt(n);                          取得字串第n+1個字元為何
   name.isEmpty();                          檢查是否為空字串
   name.trim();                             把字串的空白部分都刪掉
   name.replace('n', 'm')                   把n改成m
   name.equals("string")                    判斷 name=="string"
*/
/* 儲存型態
   1.基本類型: byte, short, int, long, double, float, boolean, char
        沒有函數可以使用
        在stack棧內存中儲存值
   2.引用類型: String, class, Array,...
        可以使用很多函數
        在stack棧內存中儲存地址，地址裡有個heap堆內存
   3.wrapper class: 基本類型所對應的類別
        byte--->Byte
        short--->Short
            .
            .
            .
        int--->Integer
        char--->character
        這樣基本型態就會變成引用型態，可以使用很多類別裡的函數
        (ex:toString()把原型態轉換為字串、Integer.parseInt()把字串換為整數、Double.parseDouble()把字串轉換為浮點數
        、Boolean.parseBoolean("true")把字串轉換為布林值)
*/
/* constructor overloading:建構方法名字一樣可以，但是參數數量or參數形態要不一樣
*/
/* 儲存物件的陣列
   class[] array = {..., ..., ...};         創建物件陣列
   class[] array = new class[n];            創建大小為n的物件陣列
*/
/* object passing
   不痛類別間中，方法的參數可以傳入其他類別型態
*/
/* public, private
   class中，把屬性或方法設定成private就只能在該class裡使用，不能在其他地方使用
   public就是在所有地方都能用
*/
/* final variable: 設定一個永遠無法改變的變數，
   final datatype name = value;
   不過引用類型的變數若為final其值還是可以被做更改，不能被更改的是其地址
   final變數的名字習慣全部用大寫
*/
/* static attribute, method靜態屬性、方法
   class中所有object的共用屬性、方法，另外存入堆內存的空間，就不用每個地址內都重複寫一樣的方法或屬性，以節省記憶體空間
   靜態屬性及方法屬於class本身而不是物件，所以使用靜態屬性及方法不需要創建該class的物件即可使用
*/
/* encapsulation封裝: 通常class的屬性的值不想被不合理的更改，此時就會需要封裝
   封裝步驟: 先將欲封裝屬性設為private，設立get方法(取得屬性值)以及set方法(更改屬性值)，
   在方法裡寫入一些限制條件使得屬性的取得以及更改合理
*/
/* inheritance繼承:如果class與class之間有重複的屬性、方法，可以使用繼承，這樣就可以少寫很多的程式碼
   寫法: public class Name extends parents{
        }
*/
/* super keyword
   要用繼承的屬性可以寫super.不要用this.，雖然用this.也可以跑但這樣比較好分辨是繼承來的還是本身class有的
*/
/* override覆寫: 子類繼承父類後，可改寫其方法，取相同名字然後做更改就好了
*/
/* package 套件(包):把性值相像的classes包在通一個資料夾裡面
   要引入才能使用: import 套件名稱.類別名稱;
*/
/* access modifier存取修飾符: public(都能用), private(同一類別), protected(同一類別~不同套件子類別), default(同一類別~同套件非子類別)
*/
/* Java的main函數都會自動繼承內建的object類別，其中有一個方法較toString(), 當創建一個類別型態並印出時，toString()會印出class@記憶體位置
   如果想要改變印出內容，可以覆寫toString()
   @override
   public String toString(){}
*/
/* polymorphism多態性: 子類物件可以表示成父類或是子類型態都可以
*/
/* abstract class, method 抽象類別、方法:
   一個許多類別的共同行為或屬性的集合，供其他類別繼承使用
   抽象類別無法被創建
   抽象方法只能在抽象類別中，且繼承抽象類別的人一定也要覆寫其抽象方法
   寫法: public abstract class Name(){
        }
        public abstract datatype method(){
        }
*/
/* interface接口: 是一個全部都是抽象方法的抽象類別
        public interface Walkable{
            void walk();                                                    不用設定abstract，在interface裡一定是abstract
        }

   有點像繼承，但接口會指定連接其的class必須要有哪些行為，且只能繼承一個class但可以有好幾個接口
   寫法: public class Name implements interface1, interface2, ...(){
        }
*/
/* Array list動態陣列: 原本的陣列沒有彈性，一開始就會把大小決定好，而arraylist則是可以使陣列的大小是彈性的
   寫法: import java.util.Arraylist
        Arraylist<引用類型> names = new Arraylist<>()                         創建動態陣列，<>只能放引用類型的資料(String, Wrapper class, ...)
        names.add("");                                                      加入資料進動態陣列
        names.get(n);                                                       取得動態陣列中第n位
        names.set(n, m);                                                    把第n位改成m
        names.remove(n);                                                    把第n位刪掉
        names.clear();                                                      把陣列清空
        names.size();                                                       取得陣列大小
        names.contains(n);                                                  判斷陣列中是否包含n
*/
/* 2D Arraylist
   寫法: Arraylist<Arraylist<引用類型>> names = new Arraylist<>()
        names.get(n).get(m);                                                取得第n個陣列中的第m個值
        names.get(n).add(m);                                                在第n個陣列加入新的值m
        names.get(n).remove(m);                                             移除第n個陣列中的第m個值
        names.get(n).set(i, j);                                             在第n個陣列中，把第i個值改成j
*/
/* generics: 定義method, class, interface時， 可以先不指定資料型態，到使用時才指定
   寫法:
   1.method:
        public <T> void method(T param){

        }
   2.class:
        public class MyGenericsClass <T, K> {                                               可以有多個泛型
            T value;
            K value2;

            public MyGenericsClass(T value, K value2){
                this.value = value;
                this.value2 = value2;
            }

            public T getValue(){
                return this.value;
            }

            public void setValue(T value){
                this.value = value;
            }

        }

        void main(){
                MyGenericsClass<String, Integer> a = new MyGenericsClass<>("小白", 50);     呼叫時傳入的引入類型數要等於class泛型數
        }
   3.interface:跟class一樣
*/
/* 異常處理: 異常會直接中止程式，try and catch可以避免中止
   寫法:
        try{

        }
        catch(異常型態 e){
            System.out.print(e.getMessage());                                               可以取得異常訊息
        }
        catch(Exception e){                                                                 不管什麼錯誤都會被捕捉

        }
        finally{                                                                            不管有沒有發生錯誤都會執行

        }
*/ 拋出異常throw, throws: 自己定義異常
   寫法:
        public static boolean canDrive(int age) throws IllegalArgumentException{                         聲明會有IOException異常
                if(age<=0){
                    throw new IllegalArgumentException("不能輸入小於等於0的數");                             創建新的異常
        }
        有些異常一定要做聲明和處理(try)，例如: Exception, IOException
*/
/* FileWriter寫檔案
   寫法:
        import java.io.FileWriter;

        try{                                                                                  因為是IOException所以要馬上處理這項錯誤
            FileWriter writer = new FileWriter("檔案位置", true);                               創建file writer，如果該檔案位制不存在，會直接建立一個新的檔案
                                                                                              ，第二個參數如果是false會覆寫，true會續寫
            writer.write("寫入內容");
            writer.close();                                                                   寫完一定要關起來
        }
        catch(IOException e){

        }
*/
/* FileReader讀檔案
   寫法:
        import java.io.FileWriter;

        try{
            FileReader reader = new FileReader("檔案位置");                                    創建file reader
            int data = reader.read();                                                         讀法是讀取檔案中一次一個字元，並回傳一個整數，所以要取得字元要轉換
            while(data!=-1){                                                                  讀到最後一位
                System.out.print((char)data);                                                 (char)data可以把讀取到的轉換成字元
                data = reader.read();
            }
            reader.close();                                                                   讀完一定要關起來
        }
        catch(FileNotFoundException e){

        }
        catch(IOException e){

        }
   一次讀取一行的方法:
        import java.io.BufferedReader;

        try{
            FileReader fileReader = new FileReader("檔案位置");
            BufferedReader buffReader = new BufferedReader(fileReader);
            String Line = buffReader.readLine();
            while(line!=null){
                System.out.println(line);
                String Line = buffReader.readLine();                                              BufferedReader搭配FileReader可以讀取一行
            }
            buffReader.close();
        }
        catch(IOException e){

        }
*/
/* main方法參數:
        void main(String[] args){

        }
        可以在右上角點選edit confiqurations，program arguments中輸入參數，可以輸入多個參數
        常用來輸入檔案位置
        args[n]     取得第n個參數
*/
/* thread: 執行緒，程式可以執行的地方
   multithreading: 一個程式拆分在多個執行緒同時執行，平行處理
       Thread.activeCount();                                               取得執行緒數目
       Thread.currentThread().setName("87");                                更改執行緒名稱
       Thread.currentThread().getName();                                    取得執行緒名稱
       Thread.currentThread().isAlive();                                    確認執行緒是否還存在
       Thread.sleep(n)                                                      讓執行緒每n毫秒才執行一段程式碼

   創建執行緒:創建一個class
   1.繼承Thread且必須覆寫override run
        public class Task1 extends Thread {
            @Override
            public void run(){
            }
        }

     再到main裡創建一個新的Thread:
        Task1 t1 = new Task1();                                              創建新的Thread
        t1.start();                                                          執行run裡的程式
   2.實現接口Runnable且必須覆寫override run
        public class Task2 implements Runnable {
            @Override
            public void run(){
            }
        }
     再到main裡創建一個新的Thread:
        Task2 runnable = new Task2();
        Thread t2 = new Thread(runnable);                                    多了要用Thread創建的步驟
        t2.start();
*/

**class note

package note;                                                        // 表示此class在people這個套件

public class Person {
    public String name;                                                // 屬性
    private int age;
    public final double height;                                        // final變數
    public static int totalPerson = 0;                                 // static表示靜態屬性

    public Person(String name, int age, double height){                       // 建構方法:每次創建便會執行的方法，與class同名
        this.name = name;                                              // 每次創建後都會做的事可以放到建構方法來做
        this.age = age;                                                // this.的意思就是指類別裡的屬性
        this.height = height;
        Person.totalPerson++;                                          // Person.表示其屬於整個class
    }

    public void sayHi() {                                                     // method: class裡的函數
        System.out.println("你好啊，我叫" + name);                       // void表示函數不需要回傳值
    }

    public boolean isAdult() {                                                // 有回傳值，函數的資料型態要與回傳值相同
        if(age>=18) {
            return true;
        }else{
            return false;
        }
    }
    public int addUp(int num1, int num2) {                                    // 傳入參數至方法
        return num1 + num2;
    }

    public static void add() {                                                 // 靜態方法不能使用非靜態屬性、方法
        System.out.println("Hi");
    }

    public int getAge(){                                                       // 封裝，getter
        return this.age;
    }

    public void setAge(int age){                                               // 封裝，setter
        if(age<100 && age>0){
            this.age = age;
        }else{
            System.out.println("不要亂設定");
        }
    }
}

**繼承note

package note;                                                             // 表示此class在people這個套件

public class Students.Student extends Person {                                       // 繼承person(父類)的所有屬性、方法
    public int score;

    public Students.Student(String name, int age, double height, int score){         // 建構方法
        super(name, age, height);                                           // super會呼叫父類建構方法，就不用重新寫一次person寫過的建構
        this.score = score;
    }

    public static void add(int num1, int num2){
        System.out.println(num1+num2);
    }

    @Override
    public void sayHi() {                                                     // method: class裡的函數
        System.out.println("你好啊，我叫"+super.name+"我的成績為"+this.score);    // void表示函數不需要回傳值
    }
}
